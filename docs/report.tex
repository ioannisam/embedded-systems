\documentclass{article}

\usepackage{geometry}
\geometry{a4paper, margin=1in}

\usepackage{microtype}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{amsmath}

\usepackage{hyperref}
\usepackage{cleveref}

\title{Producer-Consumer System Analysis}
\author{Ioannis Michalainas}
\date{April 2025}

\begin{document}

\maketitle

\begin{abstract}
This assignment investigates the performance of a multi-threaded producer-consumer system where \textit{p} producer threads generate computational tasks and \textit{q} consumer threads process them. The average task waiting time is measured to evaluate the impact of consumer count on performance and to identify optimal thread configurations.
\end{abstract}

\section{Introduction}
The implemented system uses a shared FIFO queue to coordinate work between producer and consumer threads. Producers generate computational tasks involving sine evaluations of the form $\sin(0.1k\pi)$ for $k = 1,\ldots,10$, which are then processed by consumer threads. Key design elements include:
\begin{itemize}
    \item Bounded queue capacity: 10 tasks
    \item Thread synchronization via mutexes and condition variables
    \item Poison pill termination mechanism
\end{itemize}

\section{Methodology}
Each producer thread generated 100{,}000 tasks. Timestamps were recorded at the moment of task enqueueing using \texttt{gettimeofday()} and consumers measured the elapsed time upon dequeuing to determine each taskâ€™s residence time in the queue. For each producer count (1--5), the number of consumer threads was varied from 1 to 6. The results were averaged over five runs per configuration to minimize variability. Visualization was done using Python's \texttt{matplotlib}.

\section{Results and Discussion}

\subsection{System Specifications}
The experiments were conducted on an Arch Linux system with the following hardware and system specifications:
\begin{itemize}
    \item \textbf{Processor:} Intel(R) Pentium(R) Silver N5030 CPU [1.1\,GHz - 3.1\,GHz]
    \item \textbf{Cores:} 4 physical cores (no hyper-threading)
    \item \textbf{Memory:} 4\,GB RAM
\end{itemize}

\subsection{Waiting Time Trends}
Figure~\ref{fig:results} shows the average task waiting time versus consumer threads across producer configurations. Key observations include:
\begin{itemize}
    \item For 1 producer (Figure~\ref{fig:prod1}), wait time decreased from 46.97\,$\mu$s (1 consumer) to 41.87\,$\mu$s (6 consumers).
    \item For 4 producers (Figure~\ref{fig:prod4}), the optimal configuration was 4 consumers (65.16\,$\mu$s), aligning with core count.
    \item For 3 producers (Figure~\ref{fig:prod3}), performance degraded with additional consumers, favoring 1 thread (59.21\,$\mu$s).
\end{itemize}

\begin{figure}[ht]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{p1.png}
        \caption{1 Producer}
        \label{fig:prod1}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{p2.png}
        \caption{2 Producers}
        \label{fig:prod2}
    \end{subfigure}
    \\
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{p3.png}
        \caption{3 Producers}
        \label{fig:prod3}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{p4.png}
        \caption{4 Producers}
        \label{fig:prod4}
    \end{subfigure}
    \\
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{p5.png}
        \caption{5 Producers}
        \label{fig:prod5}
    \end{subfigure}
    \caption{Average task waiting time versus consumer threads.}
    \label{fig:results}
\end{figure}

\subsection{Explanation of Trends}
The observed behavior can be attributed to four main factors:
\begin{enumerate}
    \item \textbf{Lightweight Task Complexity:} Each task executed 10 sine computations (~1\,$\mu$s total), which remained insufficient to offset synchronization overheads (~1--10\,$\mu$s). Consumers often idled, allowing more threads to reduce queue residency time.
    
    \item \textbf{Queue Contention:} The 10-task queue forced frequent producer blocking. Additional consumers reduced queue dwell time but increased mutex contention for 3+ producers.
    
    \item \textbf{Core Utilization:} For 4 producers, 4 consumers maximized parallel execution on the 4-core CPU. Oversubscription (6 consumers) introduced context-switching penalties.
    
    \item \textbf{Anomalous 3-Producer Case:} Thread contention outweighed parallelism benefits, favoring fewer consumers. Measurement variability during lengthy runs may also contribute.
\end{enumerate}

\subsection{Hardware Limitations}
The Intel Pentium N5030 CPU lacks hyper-threading, limiting parallel execution to 4 threads. However, the Linux scheduler efficiently managed oversubscribed threads (e.g., 6 consumers), reducing context-switch penalties for lightweight tasks.

\end{document}